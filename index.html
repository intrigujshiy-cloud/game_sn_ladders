<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Planet Game: Crystal Rainbow Ultra</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Comfortaa:wght@700&family=Bungee&family=Kelly+Slab&family=Monoton&family=Pacifico&family=Ruslan+Display&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #1a1a1a; }
        canvas { display: block; }
        #panel {
            position: absolute; left: 10px; top: 10px; width: 340px; 
            background: rgba(0,0,0,0.95); padding: 15px; border-radius: 10px;
            z-index: 100; color: white; border: 1px solid #444;
            max-height: 95vh; overflow-y: auto; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #turn-indicator {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            padding: 10px 20px; background: rgba(0,0,0,0.8); color: gold;
            border: 2px solid gold; border-radius: 20px; font-weight: bold;
            z-index: 50; display: none; font-size: 18px;
        }
        .input-wrap { position: relative; display: flex; align-items: center; margin-bottom: 8px; }
        .clear-btn { 
            position: absolute; right: 5px; background: none; border: none; 
            color: #888; cursor: pointer; font-size: 18px; font-weight: bold; 
            padding: 0 5px; line-height: 1; z-index: 5;
        }
        .tasks-row { display: flex; gap: 10px; margin-bottom: 10px; }
        .tasks-row textarea { height: 80px; resize: none; flex: 1; background: #222; color: white; border: 1px solid #555; border-radius: 4px; padding: 5px; }
        .colors-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        input, select { width: 100%; background: #222; color: white; border: 1px solid #555; padding: 5px; box-sizing: border-box; border-radius: 4px; }
        .btn { width: 100%; padding: 10px; margin-bottom: 5px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; color: white; }
        #task-modal { 
            display: none; position: fixed; top: 50%; left: 50%; 
            transform: translate(-50%, -50%) scale(0.8); 
            width: 400px; padding: 30px; border-radius: 20px; 
            z-index: 10000; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.5); 
            border: 2px solid #f0e68c; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background-size: cover; background-position: center;
        }
        #task-modal.show { transform: translate(-50%, -50%) scale(1); display: block; }
        #victory-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(45deg, #ff9999, #ffcc99, #ffff99, #99ff99, #99ccff, #cc99ff); background-size: 400% 400%; animation: rainbowMove 6s ease infinite; z-index: 20000; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        @keyframes rainbowMove { 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
    </style>
</head>
<body>

<div id="turn-indicator">–•–û–î –ò–ì–†–û–ö–ê: 1</div>

<div id="panel">
    <h3 style="margin:0 0 10px 0; color: #4CAF50;">3D Planet Editor: Ultra</h3>
    <div class="input-wrap"><input type="text" id="bg-url" placeholder="–°—Å—ã–ª–∫–∞ –Ω–∞ –§–û–ù –ò–ì–†–´" oninput="update()"></div>
    <div class="input-wrap"><input type="text" id="modal-bg-url" placeholder="–°—Å—ã–ª–∫–∞ –Ω–∞ –§–û–ù –û–ö–ù–ê" oninput="update()"></div>
    <div class="input-wrap"><input type="text" id="music-url" placeholder="–ú–£–ó–´–ö–ê (URL)" oninput="update()"></div>
    
    <label style="font-size:10px">–®–†–ò–§–¢:</label>
    <select id="game-font" onchange="update()">
        <option value="Arial">Arial</option>
        <option value="'Press Start 2P'">8-Bit</option>
        <option value="'Comfortaa'">Comfortaa</option>
        <option value="'Pacifico'">Pacifico</option>
    </select>

    <div class="colors-grid" style="margin-top:10px">
        <label style="font-size:10px">–ò–≥—Ä–æ–∫–æ–≤: <select id="p-count" onchange="update()"><option value="2">2</option><option value="3">3</option><option value="4" selected>4</option></select></label>
        <label style="font-size:10px">–°–∫–∏–Ω –∫—É–±–∏–∫–∞: <select id="dice-skin" onchange="update()"><option value="classic">–ö–ª–∞—Å—Å–∏–∫–∞</option><option value="neon">–ù–µ–æ–Ω</option><option value="glass">–°—Ç–µ–∫–ª–æ</option></select></label>
    </div>

    <div class="tasks-row">
        <textarea id="qs" placeholder="–í–æ–ø—Ä–æ—Å—ã..." oninput="update()"></textarea>
        <textarea id="ans" placeholder="–û—Ç–≤–µ—Ç—ã..." oninput="update()"></textarea>
    </div>

    <button id="link-btn" class="btn" style="background:#9c27b0" onclick="toggleLinkMode()">–°–≤—è–∑–∞—Ç—å (–ó–º–µ–∏/–õ–µ—Å—Ç–Ω–∏—Ü—ã)</button>
    <button class="btn" style="background:#2196F3" onclick="save()">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –°—Å—ã–ª–∫—É</button>
    <button class="btn" style="background:#673ab7" onclick="getIframe()">–ü–æ–ª—É—á–∏—Ç—å –ö–æ–¥ iFrame</button>
    <button class="btn" style="background:#f44336" onclick="state.points = []; state.links = []; update();">–û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ</button>
</div>

<div id="victory-overlay" onclick="location.reload()">
    <h1 id="vic-title" style="font-size: 60px;">VICTORY! üèÜ</h1>
</div>

<div id="task-modal">
    <h2 id="modal-status">–ó–ê–î–ê–ù–ò–ï!</h2>
    <div id="task-question" style="font-size:22px; margin-bottom:20px; font-weight:bold;"></div>
    <input type="text" id="answer-input" style="background:white; color:black; padding:10px; margin-bottom:10px">
    <button id="check-btn" class="btn" onclick="checkAnswer()">–ü–†–û–í–ï–†–ò–¢–¨</button>
</div>

<canvas id="cvs"></canvas>

<script>
    const cvs = document.getElementById('cvs');
    const ctx = cvs.getContext('2d');
    const bgMusic = new Audio(); bgMusic.loop = true;
    let audioCtx = null;

    let state = { 
        bg: '', modalBgImg: '', music: '', points: [], links: [], tasks: [], 
        playerCount: 4, diceSkin: 'classic', font: 'Arial',
        colors: { dots: '#ffffff', modalBg: '#fff9e6', modalTxt: '#333333', btnBg: '#4CAF50' },
        cellSize: 60, tokenW: 50, tokenH: 50
    };

    let isGame = false;
    let dragIdx = null;
    let diceVal = "?";
    let isRoll = false;
    let currentPlayer = 0;
    let isLinkMode = false;
    let linkFrom = null;
    let trailParticles = [];
    let hue = 0;

    let tPos = [
        {x:100, y:100, tx:100, ty:100, color:'red'},
        {x:150, y:100, tx:150, ty:150, color:'blue'},
        {x:100, y:150, tx:100, ty:150, color:'green'},
        {x:150, y:150, tx:150, ty:150, color:'yellow'}
    ];

    function encode(o) { return btoa(unescape(encodeURIComponent(JSON.stringify(o)))); }
    function decode(s) { return JSON.parse(decodeURIComponent(escape(atob(s)))); }

    function init() {
        const urlParams = new URLSearchParams(window.location.search);
        const data = urlParams.get('game');
        const mode = urlParams.get('mode');

        // –£–º–Ω–æ–µ —Å–∫—Ä—ã—Ç–∏–µ: –µ—Å–ª–∏ –≤–Ω—É—Ç—Ä–∏ iframe –ò–õ–ò –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ –ò–õ–ò —Ñ–ª–∞–≥ play
        if (window.self !== window.top || (data && data.length > 20) || mode === 'play') {
            if (data) {
                try {
                    state = decode(data);
                    isGame = true;
                    document.getElementById('panel').style.display = 'none';
                    document.getElementById('turn-indicator').style.display = 'block';
                } catch(e) { console.error("Data error"); }
            }
        }

        window.addEventListener('resize', () => { cvs.width = window.innerWidth; cvs.height = window.innerHeight; });
        cvs.width = window.innerWidth; cvs.height = window.innerHeight;
        
        // –ù–∞—á–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ —Ñ–∏—à–µ–∫ –≤ —É–≥–ª—É
        tPos.forEach((p, i) => { 
            p.x = p.tx = cvs.width - 150 + (i%2)*60; 
            p.y = p.ty = 50 + Math.floor(i/2)*60; 
        });

        if(state.music) bgMusic.src = state.music;
        animate();
    }

    function update() {
        if(isGame) return;
        state.bg = document.getElementById('bg-url').value;
        state.modalBgImg = document.getElementById('modal-bg-url').value;
        state.music = document.getElementById('music-url').value;
        state.playerCount = parseInt(document.getElementById('p-count').value);
        state.diceSkin = document.getElementById('dice-skin').value;
        state.font = document.getElementById('game-font').value;
        
        const qs = document.getElementById('qs').value.split('\n');
        const ans = document.getElementById('ans').value.split('\n');
        state.tasks = qs.map((q, i) => ({ q: q.trim(), a: (ans[i] || '').trim() })).filter(t => t.q);
    }

    function animate() {
        hue = (hue + 1) % 360;
        ctx.clearRect(0, 0, cvs.width, cvs.height);
        
        // –§–æ–Ω
        if(state.bg) {
            let img = new Image(); img.src = state.bg;
            if(img.complete) ctx.drawImage(img, 0, 0, cvs.width, cvs.height);
        }

        // –•–≤–æ—Å—Ç—ã
        trailParticles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.02;
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, 7); ctx.fill();
            if(p.life <= 0) trailParticles.splice(i, 1);
        });
        ctx.globalAlpha = 1.0;

        // –°–≤—è–∑–∏
        state.links.forEach(l => {
            const f = state.points[l.from], t = state.points[l.to];
            if(f && t) {
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.moveTo(f.x*cvs.width, f.y*cvs.height);
                ctx.lineTo(t.x*cvs.width, t.y*cvs.height);
                ctx.strokeStyle = "rgba(255,255,255,0.5)";
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });

        // –¢–æ—á–∫–∏ (–ö—Ä–∏—Å—Ç–∞–ª–ª—ã)
        state.points.forEach((p, i) => {
            const px = p.x * cvs.width, py = p.y * cvs.height;
            ctx.save();
            ctx.shadowBlur = 15; ctx.shadowColor = state.colors.dots;
            ctx.beginPath();
            ctx.arc(px, py, state.cellSize/2, 0, Math.PI*2);
            ctx.fillStyle = (linkFrom === i) ? "#ff0055" : "rgba(255,255,255,0.2)";
            ctx.fill();
            ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
            ctx.restore();
            if(!isGame) {
                ctx.fillStyle = "white"; ctx.font = "12px Arial"; ctx.textAlign="center";
                ctx.fillText(i+1, px, py+5);
            }
        });

        // –§–∏—à–∫–∏
        for(let i=0; i < (isGame ? state.playerCount : 4); i++) {
            let p = tPos[i];
            let oldX = p.x, oldY = p.y;
            p.x += (p.tx - p.x) * 0.2; p.y += (p.ty - p.y) * 0.2;
            
            if(Math.hypot(p.x - oldX, p.y - oldY) > 0.5) {
                trailParticles.push({x: p.x, y: p.y, vx: (Math.random()-0.5), vy: (Math.random()-0.5), life: 1, color: ['red','blue','green','yellow'][i]});
            }

            ctx.save();
            ctx.shadowBlur = 10; ctx.shadowColor = ['red','blue','green','yellow'][i];
            ctx.fillStyle = ['red','blue','green','yellow'][i];
            ctx.beginPath(); ctx.arc(p.x, p.y, 20, 0, 7); ctx.fill();
            ctx.restore();
        }

        // –ö—É–±–∏–∫
        const dx = cvs.width - 110, dy = cvs.height - 110;
        ctx.save();
        if(state.diceSkin === 'neon') { ctx.shadowBlur = 15; ctx.shadowColor = "cyan"; ctx.strokeStyle = "cyan"; }
        ctx.fillStyle = state.diceSkin === 'glass' ? "rgba(255,255,255,0.3)" : "white";
        ctx.beginPath(); ctx.roundRect(dx, dy, 80, 80, 15); ctx.fill(); if(state.diceSkin !== 'classic') ctx.stroke();
        ctx.fillStyle = "black"; ctx.font = `bold 40px ${state.font}`; ctx.textAlign="center";
        ctx.fillText(diceVal, dx+40, dy+55);
        ctx.restore();

        requestAnimationFrame(animate);
    }

    cvs.onmousedown = (e) => {
        const x = e.clientX, y = e.clientY;
        if (x > cvs.width - 110 && y > cvs.height - 110) {
            diceVal = Math.floor(Math.random() * 6) + 1;
            if(isGame) {
                currentPlayer = (currentPlayer + 1) % state.playerCount;
                document.getElementById('turn-indicator').innerText = "–•–û–î: –ò–ì–†–û–ö " + (currentPlayer + 1);
                if(state.tasks.length > 0) setTimeout(showTask, 500);
                if(bgMusic.paused && state.music) bgMusic.play();
            }
            return;
        }

        for(let i=0; i<4; i++) if(Math.hypot(x-tPos[i].x, y-tPos[i].y) < 30) { dragIdx = 't'+i; return; }

        if (!isGame) {
            if (isLinkMode) {
                state.points.forEach((p, i) => {
                    if (Math.hypot(x - p.x*cvs.width, y - p.y*cvs.height) < 30) {
                        if (linkFrom === null) linkFrom = i;
                        else { state.links.push({from: linkFrom, to: i}); linkFrom = null; }
                    }
                });
            } else {
                state.points.push({ x: x/cvs.width, y: y/cvs.height });
            }
        }
    };

    cvs.onmousemove = (e) => {
        if(dragIdx && dragIdx.startsWith('t')) {
            let i = dragIdx[1];
            tPos[i].tx = e.clientX; tPos[i].ty = e.clientY;
        }
    }

    cvs.onmouseup = () => {
        if(dragIdx && dragIdx.startsWith('t')) {
            let i = dragIdx[1];
            state.points.forEach((p, pIdx) => {
                if(Math.hypot(tPos[i].tx - p.x*cvs.width, tPos[i].ty - p.y*cvs.height) < 40) {
                    tPos[i].tx = p.x*cvs.width; tPos[i].ty = p.y*cvs.height;
                    const link = state.links.find(l => l.from === pIdx);
                    if(link) {
                        setTimeout(() => {
                            tPos[i].tx = state.points[link.to].x*cvs.width;
                            tPos[i].ty = state.points[link.to].y*cvs.height;
                        }, 500);
                    }
                }
            });
        }
        dragIdx = null;
    }

    function showTask() {
        const task = state.tasks[Math.floor(Math.random() * state.tasks.length)];
        const m = document.getElementById('task-modal');
        m.style.fontFamily = state.font;
        document.getElementById('task-question').innerText = task.q;
        m.setAttribute('data-ans', task.a);
        m.classList.add('show');
    }

    function checkAnswer() {
        const m = document.getElementById('task-modal');
        if(document.getElementById('answer-input').value.toLowerCase().trim() === m.getAttribute('data-ans').toLowerCase().trim()) {
            m.classList.remove('show');
            document.getElementById('answer-input').value = "";
        } else alert("–ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑!");
    }

    function toggleLinkMode() { isLinkMode = !isLinkMode; linkFrom = null; }

    function save() {
        const url = window.location.origin + window.location.pathname + "?game=" + encode(state) + "&mode=play";
        navigator.clipboard.writeText(url);
        alert("–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!");
    }

    function getIframe() {
        const url = window.location.origin + window.location.pathname + "?game=" + encode(state) + "&mode=play";
        const code = `<iframe src="${url}" width="100%" height="800" style="border:none;" allow="autoplay; fullscreen"></iframe>`;
        navigator.clipboard.writeText(code);
        alert("–ö–æ–¥ iFrame –¥–ª—è Genially —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!");
    }

    init();
</script>
</body>
</html>
